/**
 * Script para Testing Inmediato del Cron Job
 * 
 * Este script permite probar el cron job de limpieza modificando temporalmente
 * su programaci√≥n para que se ejecute cada minuto durante las pruebas.
 * 
 * IMPORTANTE: Solo usar en ambiente de desarrollo/testing
 * 
 * Uso:
 * node scripts/test-cron-immediate.js
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const mysql = require('mysql2/promise');

class CronTester {
  constructor() {
    this.servicePath = path.join(__dirname, '../backend/src/modules/bimestres/bimestre-cleanup.service.ts');
    this.originalContent = null;
    this.connection = null;
    this.testRunning = false;
  }

  async init() {
    console.log('üöÄ Iniciando Test de Cron Job Inmediato\n');
    
    // Verificar que estamos en desarrollo
    if (process.env.NODE_ENV === 'production') {
      console.error('‚ùå ERROR: Este script NO debe ejecutarse en producci√≥n');
      process.exit(1);
    }
    
    try {
      // Conectar a la base de datos
      this.connection = await mysql.createConnection({
        host: process.env.DB_HOST || 'localhost',
        user: process.env.DB_USER || 'root',
        password: process.env.DB_PASSWORD || '',
        database: process.env.DB_NAME || 'planificacion_academica'
      });
      
      console.log('‚úÖ Conexi√≥n a base de datos establecida');
      return true;
    } catch (error) {
      console.error('‚ùå Error conectando a la base de datos:', error.message);
      return false;
    }
  }

  async backupServiceFile() {
    console.log('üì¶ Creando backup del archivo de servicio...');
    
    try {
      if (!fs.existsSync(this.servicePath)) {
        throw new Error('Archivo de servicio no encontrado');
      }
      
      this.originalContent = fs.readFileSync(this.servicePath, 'utf8');
      
      // Crear backup f√≠sico
      const backupPath = this.servicePath + '.backup';
      fs.writeFileSync(backupPath, this.originalContent);
      
      console.log('‚úÖ Backup creado exitosamente');
      return true;
    } catch (error) {
      console.error('‚ùå Error creando backup:', error.message);
      return false;
    }
  }

  async modifyServiceForTesting() {
    console.log('üîß Modificando servicio para testing inmediato...');
    
    try {
      let modifiedContent = this.originalContent;
      
      // Buscar y reemplazar la configuraci√≥n del cron original
      const originalCronPattern = /@Cron\(['"](.*?)['"]\)/;
      const match = modifiedContent.match(originalCronPattern);
      
      if (match) {
        console.log(`üìÖ Configuraci√≥n original encontrada: ${match[1]}`);
        
        // Reemplazar con configuraci√≥n de testing (cada minuto)
        modifiedContent = modifiedContent.replace(
          originalCronPattern,
          "@Cron('*/1 * * * *') // TESTING: Cada minuto"
        );
        
        // Agregar m√©todo de testing espec√≠fico
        const testMethod = `
  // M√âTODO AGREGADO PARA TESTING - REMOVER EN PRODUCCI√ìN
  @Cron('*/1 * * * *')
  async executeTestCleanup() {
    if (process.env.NODE_ENV === 'production') {
      this.logger.warn('Test cleanup bloqueado en producci√≥n');
      return;
    }
    
    this.logger.log('üß™ EJECUTANDO CLEANUP DE PRUEBA (cada minuto)');
    
    try {
      // Ejecutar con par√°metros de testing
      await this.executeCleanup(5); // Mantener solo 5 bimestres para pruebas
      this.logger.log('‚úÖ Cleanup de prueba completado exitosamente');
    } catch (error) {
      this.logger.error('‚ùå Error en cleanup de prueba:', error.message);
    }
  }
`;
        
        // Insertar el m√©todo antes del √∫ltimo }
        const lastBraceIndex = modifiedContent.lastIndexOf('}');
        modifiedContent = modifiedContent.slice(0, lastBraceIndex) + testMethod + modifiedContent.slice(lastBraceIndex);
        
        // Escribir archivo modificado
        fs.writeFileSync(this.servicePath, modifiedContent);
        
        console.log('‚úÖ Servicio modificado para testing');
        console.log('‚è∞ Nuevo cron: Cada minuto (*/1 * * * *)');
        return true;
      } else {
        console.error('‚ùå No se encontr√≥ configuraci√≥n de cron en el servicio');
        return false;
      }
    } catch (error) {
      console.error('‚ùå Error modificando servicio:', error.message);
      return false;
    }
  }

  async restoreServiceFile() {
    console.log('üîÑ Restaurando archivo de servicio original...');
    
    try {
      if (this.originalContent) {
        fs.writeFileSync(this.servicePath, this.originalContent);
        console.log('‚úÖ Archivo de servicio restaurado');
        
        // Eliminar backup
        const backupPath = this.servicePath + '.backup';
        if (fs.existsSync(backupPath)) {
          fs.unlinkSync(backupPath);
          console.log('üóëÔ∏è Archivo de backup eliminado');
        }
      }
    } catch (error) {
      console.error('‚ùå Error restaurando archivo:', error.message);
    }
  }

  async createTestData() {
    console.log('üìä Creando datos de prueba para el cron...');
    
    try {
      // Limpiar datos existentes
      await this.connection.execute('DELETE FROM bimestres');
      
      // Crear 8 bimestres (para que el cron mantenga 5 y elimine 3)
      const testData = [
        { nombre: 'Bimestre 2020-1', fecha: '2020-01-01' },
        { nombre: 'Bimestre 2020-2', fecha: '2020-03-01' },
        { nombre: 'Bimestre 2021-1', fecha: '2021-01-01' },
        { nombre: 'Bimestre 2021-2', fecha: '2021-03-01' },
        { nombre: 'Bimestre 2022-1', fecha: '2022-01-01' },
        { nombre: 'Bimestre 2022-2', fecha: '2022-03-01' },
        { nombre: 'Bimestre 2023-1', fecha: '2023-01-01' },
        { nombre: 'Bimestre 2023-2', fecha: '2023-03-01' }
      ];
      
      for (const data of testData) {
        await this.connection.execute(`
          INSERT INTO bimestres (nombre, fecha_inicio, fecha_fin, activo) 
          VALUES (?, ?, DATE_ADD(?, INTERVAL 2 MONTH), 0)
        `, [data.nombre, data.fecha, data.fecha]);
      }
      
      console.log(`‚úÖ Creados ${testData.length} bimestres de prueba`);
      return true;
    } catch (error) {
      console.error('‚ùå Error creando datos de prueba:', error.message);
      return false;
    }
  }

  async restartBackend() {
    console.log('üîÑ Reiniciando backend para aplicar cambios...');
    
    return new Promise((resolve) => {
      console.log('‚ö†Ô∏è INSTRUCCI√ìN MANUAL:');
      console.log('   1. Det√©n el servidor backend (Ctrl+C en la terminal del backend)');
      console.log('   2. Ejecuta: npm run start:dev');
      console.log('   3. Espera a que el servidor inicie completamente');
      console.log('   4. Presiona ENTER aqu√≠ para continuar...');
      
      process.stdin.once('data', () => {
        console.log('‚úÖ Continuando con el test...');
        resolve();
      });
    });
  }

  async monitorCronExecution() {
    console.log('üëÄ Monitoreando ejecuci√≥n del cron job...');
    console.log('‚è∞ El cron deber√≠a ejecutarse cada minuto');
    console.log('üìä Monitoreando por 3 minutos...');
    
    const startTime = Date.now();
    const monitorDuration = 3 * 60 * 1000; // 3 minutos
    let executionCount = 0;
    
    const checkInterval = setInterval(async () => {
      try {
        // Verificar logs de cleanup
        const [logs] = await this.connection.execute(`
          SELECT * FROM cleanup_logs 
          WHERE execution_date >= DATE_SUB(NOW(), INTERVAL 5 MINUTE)
          ORDER BY execution_date DESC
        `);
        
        if (logs.length > executionCount) {
          const newExecutions = logs.length - executionCount;
          executionCount = logs.length;
          
          console.log(`\nüéØ Nueva ejecuci√≥n detectada! (Total: ${executionCount})`);
          
          const lastLog = logs[0];
          console.log('üìù √öltimo log:', {
            fecha: lastLog.execution_date,
            eliminados: lastLog.bimestres_eliminados,
            status: lastLog.status,
            error: lastLog.error_message || 'Ninguno'
          });
          
          // Verificar estado actual de bimestres
          const [count] = await this.connection.execute('SELECT COUNT(*) as total FROM bimestres');
          console.log(`üìä Bimestres actuales: ${count[0].total}`);
        }
        
        // Verificar si ha pasado el tiempo de monitoreo
        if (Date.now() - startTime >= monitorDuration) {
          clearInterval(checkInterval);
          this.finishMonitoring(executionCount);
        }
      } catch (error) {
        console.error('‚ùå Error monitoreando:', error.message);
      }
    }, 10000); // Verificar cada 10 segundos
    
    // Mensaje inicial
    console.log('\n‚è≥ Esperando primera ejecuci√≥n del cron...');
    console.log('   (Si no ves actividad en 2 minutos, verifica que el backend est√© ejecut√°ndose)');
  }

  finishMonitoring(executionCount) {
    console.log('\n' + '='.repeat(50));
    console.log('üìä RESULTADO DEL MONITOREO');
    console.log('='.repeat(50));
    
    if (executionCount > 0) {
      console.log(`‚úÖ Cron job ejecutado ${executionCount} veces`);
      console.log('‚úÖ El proceso autom√°tico est√° funcionando correctamente');
      
      console.log('\nüí° Pr√≥ximos pasos:');
      console.log('   1. El archivo de servicio ser√° restaurado autom√°ticamente');
      console.log('   2. Reinicia el backend para aplicar la configuraci√≥n original');
      console.log('   3. Verifica que la configuraci√≥n vuelva a ser anual (0 2 1 1 *)');
    } else {
      console.log('‚ùå No se detectaron ejecuciones del cron job');
      console.log('\nüîç Posibles causas:');
      console.log('   - El backend no est√° ejecut√°ndose');
      console.log('   - Error en la configuraci√≥n del cron');
      console.log('   - Problema con el servicio de cleanup');
      
      console.log('\nüõ†Ô∏è Acciones recomendadas:');
      console.log('   1. Verificar logs del backend');
      console.log('   2. Comprobar que el servicio est√© registrado');
      console.log('   3. Revisar configuraci√≥n de la base de datos');
    }
    
    this.testRunning = false;
  }

  async cleanup() {
    console.log('\nüßπ Limpiando recursos...');
    
    // Restaurar archivo de servicio
    await this.restoreServiceFile();
    
    // Cerrar conexi√≥n de base de datos
    if (this.connection) {
      await this.connection.end();
    }
    
    console.log('‚úÖ Limpieza completada');
  }

  // Manejar interrupci√≥n del usuario (Ctrl+C)
  setupGracefulShutdown() {
    process.on('SIGINT', async () => {
      console.log('\n\n‚ö†Ô∏è Interrupci√≥n detectada. Limpiando...');
      this.testRunning = false;
      await this.cleanup();
      process.exit(0);
    });
  }

  async runTest() {
    this.setupGracefulShutdown();
    
    try {
      // Inicializar
      const connected = await this.init();
      if (!connected) return;
      
      // Crear backup del servicio
      const backupCreated = await this.backupServiceFile();
      if (!backupCreated) return;
      
      // Modificar servicio para testing
      const serviceModified = await this.modifyServiceForTesting();
      if (!serviceModified) {
        await this.restoreServiceFile();
        return;
      }
      
      // Crear datos de prueba
      await this.createTestData();
      
      // Instrucciones para reiniciar backend
      await this.restartBackend();
      
      // Monitorear ejecuci√≥n
      this.testRunning = true;
      await this.monitorCronExecution();
      
      // Esperar a que termine el monitoreo
      while (this.testRunning) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
    } catch (error) {
      console.error('‚ùå Error durante el test:', error);
    } finally {
      await this.cleanup();
    }
  }
}

// Ejecutar test si el script se ejecuta directamente
if (require.main === module) {
  console.log('‚ö†Ô∏è ADVERTENCIA: Este script modificar√° temporalmente el c√≥digo del servicio');
  console.log('‚ö†Ô∏è Solo usar en ambiente de desarrollo/testing');
  console.log('‚ö†Ô∏è Aseg√∫rate de tener backup de tu c√≥digo');
  console.log('\n¬øContinuar? (y/N): ');
  
  process.stdin.once('data', (data) => {
    const input = data.toString().trim().toLowerCase();
    
    if (input === 'y' || input === 'yes') {
      const tester = new CronTester();
      tester.runTest().catch(console.error);
    } else {
      console.log('Test cancelado por el usuario');
      process.exit(0);
    }
  });
}

module.exports = CronTester;